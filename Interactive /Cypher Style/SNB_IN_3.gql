
CREATE QUERY city_VIEW1 as (
FROM LDBC_SNB
MATCH (x:Country {name: $countryXName }),
      (y:Country {name: $countryYName }),
      (p:Person {id: $personId })
RETURN person
       ,x AS countryA
       ,y AS countryB
LIMIT 1
)

CREATE QUERY city_VIEW2 as (
FROM country_VIEW1
MATCH (c:City)-[:IS_PART_OF]->(c:Country)
WHERE country IN [countryA, countryB]
RETURN person
       ,countryA
       ,countryB
       ,COLLECT(c) AS cities
)

CREATE QUERY city_VIEW3 as (
FROM LDBC_SNB,city_VIEW2 
MATCH (p:Person where  p.id <> f:friend.id)-[:IS_LOCATED_IN]
       ->(c:City WHERE c.id <> c.id)
WHERE p.id == country_VIEW1.p.id 
RETURN DISTINCT f
               ,countryA
               ,countryB
)

FROM LDBC_SNB,city_VIEW3,city_VIEW2,city_VIEW1
MATCH (f:Friend)<-[:HAS_CREATOR]-(m:message),
      (m:message)-[:IS_LOCATED_IN]->(c:country)
WHERE $endDate > m.creationDate >= $startDate AND
      country IN [countryA, countryB] AND city_VIEW3.f.id == f.id
// RETURN f,
     CASE WHEN country=countryA THEN 1 ELSE 0 END AS messageA,
     CASE WHEN country=countryB THEN 1 ELSE 0 END AS messageB
//      sum(messageA) AS countA, sum(messageB) AS countB

// GROUP BY f.id 
HAVING countA >0 AND countB>0
     
// CALL {
// city_VIEW1
// UNION
// city_VIEW2
// UNION
// city_VIEW3

// Perhahps we can remove the call Option

RETURN country_VIEW1.f.id AS friend,
       country_VIEW2.f.firstName AS friend_FirstName,
       country_VIEW2.f.lastName AS friend_LastName,
       sum(messageA) AS countA
       ,sum(messageB) AS countB
       countA + countA AS ABCount
// }
ORDER BY ABCount DESC
        , friend ASC
LIMIT 20
