\subsection{Business Intelligence queries}

In the following subsections the business intelligence queries are translated or converted towards the Cypher style query.
\subsubsection{BI 1}
\renewcommand{\listingscaption}{}
\begin{listing}[!ht]
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{cypher}
CREATE QUERY messageCount_VIEW AS {
FROM message
MATCH (message:Message)
WHERE message.creationDate < $datetime
Return count(message) AS totalMessageCountInt}

\end{minted}
\caption{ message count}
\label{1}
\end{listing}


In \ref{1}  the message node is selected by the MATCH clause. After selection a verification is executed by the WHERE clause.
The verification is based on whether the creation date of the message is lower than the provided date. At last, the count of the messages are returned as totalMessage Count.


\begin{listing}[!ht]
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{cypher}
CREATE  QUERY messagePrep_View AS (
From message 
MATCH(message:message)
WHERE  creationDate < :datetime
    AND content IS NOT NULL
   SELECT extract(year from creationDate) AS messageYear
         , ParentMessageId IS NOT NULL AS isComment
             
Return ParentMessageId IS NOT NULL AS isComment,
       , CASE
             WHEN length <  40 THEN 0 -- short
             WHEN length <  80 THEN 1 -- one liner
             WHEN length < 160 THEN 2 -- tweet
             ELSE                   3 -- long
           END AS lengthCategory
         , length
)

\end{minted}
\caption{message prep}
\label{2}
\end{listing}

In \ref{2}, the MATCH clause selects the message node. Although the query construction might seem similar to \ref{1}, it is quite different.
After the match clause the where clause validates whether the original date of the message is lower than the actual date. Moreover, there is another verification carried out,
which verifies to see whether there is content or not. At last, the id of the messages is returned with their respective length category.


\begin{listing}[!ht]
\begin{minted}
[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=LightGray,
fontsize=\footnotesize,
linenos
]
{cypher}
FROM messagePrep_VIEW, messageCount_VIEW
MATCH(message:message)
Return messageYear,
       isComment, 
       lengthCategory,
       count(message) AS messageCount, 
       sum(message.length)/toFloat (count(message)) AS averageMessageLength, 
       sum(length) AS sumMessageLength, 
       messageCount / toFloat(totalMessageCountInt) AS percentageOfMessages

 GROUP BY messageYear, 
          isComment, 
          lengthCategory, 
 ORDER BY messageYear DESC, 
          isComment ASC,
          lengthCategory ASC
          
\end{minted}
\caption{final query}
\label{3}
\end{listing}


The last query is the final query and uses the returned results from \ref{1} and \ref{2}. Also here first the message node is selected and returns the results, which 
are grouped by the year, the length of the category, and the id of the parent message (variable: isComment). \\

The variables which are returned

\begin{table}[!ht]
\begin{tabular}{|l|l|lll}
\cline{1-2}
\textbf{Variables}   & \textbf{Meaning}                                                                  &  &  &  \\ \cline{1-2}
messageYear          & creation year of the message                                                      &  &  &  \\ \cline{1-2}
isComment            & id of the parent message                                                          &  &  &  \\ \cline{1-2}
lengthCategory       & length of the mesage categorized                                                  &  &  &  \\ \cline{1-2}
messageCount         & the count of how many messages based on the critera in the where clause of \ref{3} &  &  &  \\ \cline{1-2}
averageMessageLength & average length of the message                                                     &  &  &  \\ \cline{1-2}
\end{tabular}
\caption{Returned variables and their meaning}
\label{RetCypher1Table}
\end{table}

